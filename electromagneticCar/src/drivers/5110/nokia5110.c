#include "nokia5110.h"
#include "common.h"
#include "gpio.h"

struct typHZ_GB12   GB_12[] ={ 
{"距",{0xEF,0x09,0xF9,0x4F,0x40,0xFF,0x49,0x49,0x49,0x79,0x01,0x00,0x07,0x04,0x03,0x02,0x02,0x07,0x04,0x04,0x04,0x04,0x04,0x00}},
{"离",{0x02,0x82,0xBE,0xA2,0xB6,0xEB,0xB6,0xA2,0xBE,0x82,0x02,0x00,0x00,0x07,0x00,0x02,0x03,0x02,0x02,0x03,0x04,0x07,0x00,0x00}},
{"温",{0x89,0x72,0x00,0xC0,0x5F,0xD5,0x55,0xD5,0x55,0xDF,0x00,0x00,0x07,0x00,0x04,0x07,0x04,0x07,0x04,0x07,0x04,0x07,0x04,0x00}},
{"度",{0x00,0xFE,0x0A,0x8A,0xBE,0xAA,0xAB,0xAA,0xBE,0x0A,0x0A,0x00,0x06,0x01,0x04,0x04,0x04,0x03,0x02,0x03,0x04,0x04,0x04,0x00}},
{"角",{0x10,0x08,0xFC,0xAB,0xAA,0xFA,0xAE,0xAA,0xA8,0xF8,0x00,0x00,0x04,0x02,0x01,0x00,0x00,0x07,0x00,0x04,0x04,0x07,0x00,0x00}},
{"度",{0x00,0xFE,0x0A,0x8A,0xBE,0xAA,0xAB,0xAA,0xBE,0x0A,0x0A,0x00,0x06,0x01,0x04,0x04,0x04,0x03,0x02,0x03,0x04,0x04,0x04,0x00}}
//{"",{}},
};

//ASCII码编码表
 unsigned char font6x8[][6] =
{
{0x00,0x00,0x00,0x00,0x00,0x00},// (0)
{0x00,0x00,0x00,0x4F,0x00,0x00},//!(1)
{0x00,0x00,0x07,0x00,0x07,0x00},//"(2)
{0x00,0x14,0x7F,0x14,0x7F,0x14},//#(3)
{0x00,0x24,0x2A,0x7F,0x2A,0x12},//$(4)
{0x00,0x23,0x13,0x08,0x64,0x62},//%(5)
{0x00,0x36,0x49,0x55,0x22,0x50},//&(6)
{0x00,0x00,0x05,0x03,0x00,0x00},//'(7)
{0x00,0x00,0x1C,0x22,0x41,0x00},//((8)
{0x00,0x00,0x41,0x22,0x1C,0x00},//)(9)
{0x00,0x14,0x08,0x3E,0x08,0x14},//*(10)
{0x00,0x08,0x08,0x3E,0x08,0x08},//+(11)
{0x00,0x00,0x50,0x30,0x00,0x00},//,(12)
{0x00,0x08,0x08,0x08,0x08,0x08},//-(13)
{0x00,0x00,0x60,0x60,0x00,0x00},//.(14)
{0x00,0x20,0x10,0x08,0x04,0x02},///(15)
{0x00,0x3E,0x51,0x49,0x45,0x3E},//0(16)
{0x00,0x00,0x42,0x7F,0x40,0x00},//1(17)
{0x00,0x42,0x61,0x51,0x49,0x46},//2(18)
{0x00,0x21,0x41,0x45,0x4B,0x31},//3(19)
{0x00,0x18,0x14,0x12,0x7F,0x10},//4(20)
{0x00,0x27,0x45,0x45,0x45,0x39},//5(21)
{0x00,0x3C,0x4A,0x49,0x49,0x30},//6(22)
{0x00,0x01,0x71,0x09,0x05,0x03},//7(23)
{0x00,0x36,0x49,0x49,0x49,0x36},//8(24)
{0x00,0x06,0x49,0x49,0x29,0x1E},//9(25)
{0x00,0x00,0x36,0x36,0x00,0x00},//:(26)
{0x00,0x00,0x56,0x36,0x00,0x00},//;(27)
{0x00,0x08,0x14,0x22,0x41,0x00},//<(28)
{0x00,0x14,0x14,0x14,0x14,0x14},//=(29)
{0x00,0x00,0x41,0x22,0x14,0x08},//>(30)
{0x00,0x02,0x01,0x51,0x09,0x06},//?(31)
{0x00,0x32,0x49,0x79,0x41,0x3E},//@(32)
{0x00,0x7E,0x11,0x11,0x11,0x7E},//A(33)
{0x00,0x7F,0x49,0x49,0x49,0x3E},//B(34)
{0x00,0x3E,0x41,0x41,0x41,0x22},//C(35)
{0x00,0x7F,0x41,0x41,0x22,0x1C},//D(36)
{0x00,0x7F,0x49,0x49,0x49,0x41},//E(37)
{0x00,0x7F,0x09,0x09,0x09,0x01},//F(38)
{0x00,0x3E,0x41,0x49,0x49,0x7A},//G(39)
{0x00,0x7F,0x08,0x08,0x08,0x7F},//H(40)
{0x00,0x00,0x41,0x7F,0x41,0x00},//I(41)
{0x00,0x20,0x40,0x41,0x3F,0x01},//J(42)
{0x00,0x7F,0x08,0x14,0x22,0x41},//K(43)
{0x00,0x7F,0x40,0x40,0x40,0x40},//L(44)
{0x00,0x7F,0x02,0x04,0x02,0x7F},//M(45)
{0x00,0x7F,0x04,0x08,0x10,0x7F},//N(46)
{0x00,0x3E,0x41,0x41,0x41,0x3E},//O(47)
{0x00,0x7F,0x09,0x09,0x09,0x06},//P(48)
{0x00,0x3E,0x41,0x51,0x21,0x5E},//Q(49)
{0x00,0x7F,0x09,0x19,0x29,0x46},//R(50)
{0x00,0x46,0x49,0x49,0x49,0x31},//S(51)
{0x00,0x01,0x01,0x7F,0x01,0x01},//T(52)
{0x00,0x3F,0x40,0x40,0x40,0x3F},//U(53)
{0x00,0x1F,0x20,0x40,0x20,0x1F},//V(54)
{0x00,0x3F,0x40,0x38,0x40,0x3F},//W(55)
{0x00,0x63,0x14,0x08,0x14,0x63},//X(56)
{0x00,0x03,0x04,0x78,0x04,0x03},//Y(57)
{0x00,0x61,0x51,0x49,0x45,0x43},//Z(58)
{0x00,0x00,0x7F,0x41,0x41,0x00},//[(59)
{0x00,0x15,0x16,0x7C,0x16,0x15},//\(60)
{0x00,0x00,0x41,0x41,0x7F,0x00},//](61)
{0x00,0x04,0x02,0x01,0x02,0x04},//^(62)
{0x00,0x40,0x40,0x40,0x40,0x40},//_(63)
{0x00,0x00,0x01,0x02,0x04,0x00},//`(64)
{0x00,0x20,0x54,0x54,0x54,0x78},//a(65)
{0x00,0x7F,0x48,0x44,0x44,0x38},//b(66)
{0x00,0x38,0x44,0x44,0x44,0x20},//c(67)
{0x00,0x38,0x44,0x44,0x48,0x7F},//d(68)
{0x00,0x38,0x54,0x54,0x54,0x18},//e(69)
{0x00,0x08,0x7E,0x09,0x01,0x02},//f(70)
{0x00,0x0C,0x52,0x52,0x52,0x3E},//g(71)
{0x00,0x7F,0x08,0x04,0x04,0x78},//h(72)
{0x00,0x00,0x44,0x7D,0x40,0x00},//i(73)
{0x00,0x20,0x40,0x44,0x3D,0x00},//j(74)
{0x00,0x7F,0x10,0x28,0x44,0x00},//k(75)
{0x00,0x00,0x41,0x7F,0x40,0x00},//l(76)
{0x00,0x7E,0x02,0x0C,0x02,0x7C},//m(77)
{0x00,0x7E,0x04,0x02,0x02,0x7C},//n(78)
{0x00,0x38,0x44,0x44,0x44,0x38},//o(79)
{0x00,0x7C,0x14,0x14,0x14,0x08},//p(80)
{0x00,0x08,0x14,0x14,0x18,0x7C},//q(81)
{0x00,0x7C,0x08,0x04,0x04,0x08},//r(82)
{0x00,0x48,0x54,0x54,0x54,0x20},//s(83)
{0x00,0x04,0x3F,0x44,0x40,0x20},//t(84)
{0x00,0x3C,0x40,0x40,0x20,0x7C},//u(85)
{0x00,0x1C,0x20,0x40,0x20,0x1C},//v(86)
{0x00,0x3C,0x40,0x30,0x40,0x3C},//w(87)
{0x00,0x44,0x28,0x10,0x28,0x44},//x(88)
{0x00,0x0C,0x50,0x50,0x50,0x3C},//y(89)
{0x00,0x44,0x64,0x54,0x4C,0x44},//z(90)
{0x00,0x00,0x08,0x36,0x41,0x00},//{(91)
{0x00,0x00,0x00,0x7F,0x00,0x00},//|(92)
{0x00,0x00,0x41,0x36,0x08,0x00},//}(93)
{0x00,0x08,0x04,0x08,0x10,0x08},//~(94)
{0x00,0x08,0x08,0x2A,0x1C,0x08},//→(127)
{0x00,0x08,0x1C,0x2A,0x08,0x08},//←(128)
{0x00,0x04,0x02,0x7F,0x02,0x04},//↑(129)
{0x00,0x10,0x20,0x7F,0x20,0x10},//↓(130)
{0x00,0x1C,0x2A,0x32,0x2A,0x1C},//笑面(131)
{0x00,0x1C,0x22,0x44,0x22,0x1C}//爱心(132)
};



/******延时us******/
void Delay_us(uint ut)
{
  uint ux,uy;
  for(ux=0;ux<=8;ux++) 
     for(uy=ut;uy>0;uy--);
}
/**********************************************************************
* 函数名称：LCD_init()		
* 函数功能：初始化nokia5110
* 入口参数：无
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Init(void)
  {      
    gpio_init(PORTD,4,GPO,1);
    gpio_init(PORTD,2,GPO,1);
    gpio_init(PORTD,0,GPO,1);
    gpio_init(PORTC,17,GPO,1);
    gpio_init(PORTC,15,GPO,1);
    gpio_init(PORTC,13,GPO,1);

    
    LCD_RST = 0; // 产生一个让LCD复位的低电平脉冲
    Delay_us(1);
    LCD_RST = 1;
    LCD_CE = 0;// 关闭LCD  
    Delay_us(1);	
    LCD_CE = 1;// 使能LCD
    Delay_us(1);
    LCD_write_byte(0x21, 0);	// 使用扩展命令设置LCD模式
    LCD_write_byte(0xba, 0);	// 设置偏置电压
    LCD_write_byte(0x06, 0);	// 温度校正
    LCD_write_byte(0x13, 0);	// 1:48
    LCD_write_byte(0x20, 0);	// 使用基本命令
    LCD_clear();	            // 清屏
    LCD_write_byte(0x0c, 0);	// 设定显示模式，正常显示        
    LCD_CE = 0;               // 关闭LCD  
  }
  
 /**********************************************************************
* 函数名称：LCD_clear()		
* 函数功能：液晶清屏
* 入口参数：无
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_clear(void)
  {
    uint i;
    LCD_write_byte(0x0c, 0);			
    LCD_write_byte(0x80, 0);	
    for (i=0; i<504; i++)
      LCD_write_byte(0, 1);			
  }
  
/**********************************************************************
* 函数名称：LCD_write_byte()
* 函数功能：写一个字节
* 入口参数：data,要写入的字节;command:0为命令,1为数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_byte(uchar data, uchar command)
{
  uchar i;    
  LCD_CE = 0;    
  if (command == 0)     
   LCD_DC = 0;
  else    
   LCD_DC = 1;
	for(i=0;i<8;i++)
	{
		if(data&0x80)
			SDIN = 1;
		else
			SDIN = 0;
		SCLK = 0;
		data= data<< 1;
		SCLK = 1;
	}   
   LCD_CE = 1;
}

/**********************************************************************
* 函数名称：LCD_set_XY()
* 函数功能：光标定位x行y列
* 入口参数：X,Y   x行y列
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_set_XY(uchar X, uchar Y)
  {
    LCD_write_byte(0x40 | Y, 0);		// column
    LCD_write_byte(0x80 | X, 0);        // row
  }
  
 /***********************************************************************
* 函数名称：LCD_write_char()
* 函数功能：写入1个字符
* 入口参数：c   要写入的数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_write_char(uchar c)
  {
    uchar line;
    c -= 32;
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[c][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }
  
/***********************************************************************
* 函数名称：LCD_Write_Char()
* 函数功能：写入1个字符
* 入口参数：X:行;Y:列;asc:要写入的数据
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Write_Char(uchar X,uchar Y,uchar asc)
{
  uchar line;
  LCD_set_XY(X,Y);//光标定位
 // if((asc>=0)&&(asc<=9))
 //   asc = asc+16;
 // else 
    asc = asc-32;
  for (line=0; line<6; line++)
    LCD_write_byte(font6x8[asc][line], 1);//从ACSII码表中读取字节，然后写入液晶
}

/***********************************************************************
* 函数名称：LCD_Write_Num()
* 函数功能：显示变亮
* 入口参数：X:行;Y:列;num:变量;N:要显示的变量的位数
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_Write_Num(uchar X,uchar Y,uint num,uchar N)
{
  uchar line;
  uchar i=0;
  uint n[5]={0};
  /** 更改  **/
//  if(num<0)
//  {
//     num= -num+200;
//  }  
   /**   **/
  n[0]= num%10;
  n[1]=(num/10)%10;
  n[2]=(num/100)%10;
  n[3]=(num/1000)%10;
  n[4]=(num/10000)%10;
  for(i=0;i<5;i++) n[i]=n[i]+16;
  for(i=N;i>0;i--) 
  {
    LCD_set_XY(X+(N-i)*6,Y);//光标定位
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[n[i-1]][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }
}
void LCD_Write_NumChar(uchar X,uchar Y,uchar N)
{
  int i;
  uchar n[3];
  int line;
  n[0]= N%10;
  n[1]=(N/10)%10;
  n[2]=(N/100)%10;
  for(i=0;i<3;i++) n[i]=n[i]+16;
  for(i=3;i>0;i--) 
  {
    LCD_set_XY(X+(N-i)*6,Y);//光标定位
    for (line=0; line<6; line++)
      LCD_write_byte(font6x8[n[i-1]][line], 1);//从ACSII码表中读取字节，然后写入液晶
  }
}


/***********************************************************************
* 函数名称LLCD_write_english_string()
* 函数功能：写英文字符串
* 入口参数：X,Y,*S------x行y列*s为英文字符串
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_english_string(uchar X,uchar Y,char  *s)  //伙修改胡uchar
  {
    LCD_set_XY(X,Y);//光标定位
    while (*s) 
    {
  	 LCD_write_char(*s);
  	 s++;
    }
  }

/**********************************************************************
* 函数名称：LCD_write_chinesee()
* 函数功能：写一个汉字
* 入口参数：x,横坐标;y,纵坐标;hz,要显示的汉字
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
**********************************************************************/
void LCD_write_chinese(uchar x, uchar y, char *hz)
{  
   uchar k,i;
   for(k=0;k<sizeof(GB_12)/sizeof(GB_12[0]);k++)//查找汉字编码表中的汉字
     {
        if((hz[0]==GB_12[k].Index[0])&&(hz[1]==GB_12[k].Index[1]))
        break;
     }
  LCD_set_XY(x,y); //光标定位
  for(i=0;i<12;i++)//先写上半字节
  LCD_write_byte(GB_12[k].Msk[i],1);
  LCD_set_XY(x,y+1);//光标定位下一行
  for(i=12;i<24;i++)//后写下半字节
  LCD_write_byte(GB_12[k].Msk[i],1);
}

/***********************************************************************
* 函数名称： LCD_write_chinese_sring()
* 函数功能：写汉字串
* 入口参数：x,横坐标;y,纵坐标;string,要显示的汉字串
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_write_chinese_string(uchar x, uchar y,char *string)
{
  uchar i=0;
  while(string[i])
  {
      LCD_write_chinese(x,y,&string[i]);
      x=x+12;
      i=i+2;
  }
}

/***********************************************************************
* 函数名称： LCD_Write_String()
* 函数功能：写字符串(中英文)
* 入口参数：x,横坐标;y,纵坐标;String,要显示的字符串
* 出口参数：无
* 修改人  ：BDC
* 修改时间：2011/08/04
***********************************************************************/
void LCD_Write_String(uchar x, uchar y,char *string)
{
  uchar i=0,xh=0,yh=0;
  //uchar j=0,k=0; //警告后注释
  uchar kk,ii;
  char *cc;
  //chra hz[2]={0};  警告后注释 
  xh=x,yh=y;
  while(string[i])
  {
     for(kk=0;kk<sizeof(GB_12)/sizeof(GB_12[0]);kk++)//查找汉字编码表中的汉字
     {
      if((string[i]==GB_12[kk].Index[0])&&(string[i+1]==GB_12[kk].Index[1]))
       {
          LCD_set_XY(xh+i*6,yh); //光标定位
          for(ii=0;ii<12;ii++)//先写上半字节
          LCD_write_byte(GB_12[kk].Msk[ii],1);
          LCD_set_XY(xh+i*6,yh+1);//光标定位下一行
          for(ii=12;ii<24;ii++)//后写下半字节
          LCD_write_byte(GB_12[kk].Msk[ii],1);
          i=i+2;
       }
      else if((string[i]>=32)&&(string[i]<=121)) 
       {
          cc=&string[i];
          LCD_set_XY(x+i*6,y);
          LCD_write_char(*cc);
          i=i+1;
       }        
     }    
  }    
}

/*********************************************************** 
*函数名称：LCD_draw_bmp_pixel
*函数功能：位图绘制函数
*入口参数：X、Y    ：位图绘制的起始X、Y坐标；
           *map    ：位图点阵数据；
           Pix_x   ：位图像素（长）
           Pix_y   ：位图像素（宽）
*出口参数：无 
*修改人  ：BDC
*修改时间：2011/08/04
*备 注： 
***********************************************************/
void LCD_draw_bmp_pixel(uchar X,uchar Y,uchar *map, uchar Pix_x,uchar Pix_y)
{
    uint i,n;
    uchar row;
    						    //计算位图所占行数
      if (Pix_y%8==0) 		//如果为位图所占行数为整数
	     row=Pix_y/8;      
      else
         row=Pix_y/8+1;		//如果为位图所占行数不是整数
    
	LCD_set_XY(X,Y);
    for (n=0;n<row;n++)		//换行
      {	
        for(i=0;i<Pix_x;i++)
          {	
		     LCD_set_XY(X+i,Y+n);
             LCD_write_byte(map[i+n*Pix_x], 1);
          }                         
      }      
}
